Pass Arguments:  -targetlibinfo -datalayout -array-check -effect-gen -very-busy-analysis -modify-check -preverify -domtree -verify -print-module
Target Library Information
Data Layout
  ModulePass Manager
    Insert Run-Time Array Bounds Checks
    Effect Generation
    Global Very Busy Array Bound Checks Analysis
    Modify Array Bound Checks using very busy checks
    FunctionPass Manager
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
    Print module to stderr
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx = getelementptr inbounds [300 x i32]* %a, i32 0, i64 %idxprom
Base Pointer Type: [300 x i32]*
Base Pointer   %a = alloca [300 x i32], align 16
Origin Base Pointer:   %a = alloca [300 x i32], align 16

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0

Index (Non-constant):   %idxprom = zext i32 %3 to i64
NumElements: 300
Origin Index:   %3 = load i32* %i, align 4
var1:   %i = alloca i32, align 4
var2: i64 300
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx2 = getelementptr inbounds i32* %vla, i64 %idxprom1
Base Pointer Type: i32*
Base Pointer   %vla = alloca i32, i64 %1, align 16
Origin Base Pointer:   %vla = alloca i32, i64 %1, align 16

First Index (Non-constant):   %idxprom1 = zext i32 %add to i64
VLA Detected2
index:   %idxprom1 = zext i32 %add to i64
limit:   %1 = zext i32 %0 to i64
var1:   %add = add i32 %4, 1
var2:   %n = alloca i32, align 4
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx4 = getelementptr inbounds i32* %vla, i64 %idxprom3
Base Pointer Type: i32*
Base Pointer   %vla = alloca i32, i64 %1, align 16
Origin Base Pointer:   %vla = alloca i32, i64 %1, align 16

First Index (Non-constant):   %idxprom3 = zext i32 %5 to i64
VLA Detected2
index:   %idxprom3 = zext i32 %5 to i64
limit:   %1 = zext i32 %0 to i64
var1:   %i = alloca i32, align 4
var2:   %n = alloca i32, align 4
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx6 = getelementptr inbounds [300 x i32]* %a, i32 0, i64 %idxprom5
Base Pointer Type: [300 x i32]*
Base Pointer   %a = alloca [300 x i32], align 16
Origin Base Pointer:   %a = alloca [300 x i32], align 16

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0

Index (Non-constant):   %idxprom5 = zext i32 %6 to i64
NumElements: 300
Origin Index:   %6 = load i32* %i, align 4
var1:   %i = alloca i32, align 4
var2: i64 300
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arr = getelementptr inbounds %struct.st* %strt, i32 0, i32 0
Base Pointer Type: %struct.st*
Base Pointer   %strt = alloca %struct.st, align 4
Origin Base Pointer:   %strt = alloca %struct.st, align 4

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx8 = getelementptr inbounds [100 x i8]* %arr, i32 0, i64 %idxprom7
Base Pointer Type: [100 x i8]*
Base Pointer   %arr = getelementptr inbounds %struct.st* %strt, i32 0, i32 0
Origin Base Pointer:   %strt = alloca %struct.st, align 4

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0

Index (Non-constant):   %idxprom7 = zext i32 %7 to i64
NumElements: 100
Origin Index:   %7 = load i32* %i, align 4
var1:   %i = alloca i32, align 4
var2: i64 100
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %float_arr = getelementptr inbounds %struct.st* %strt, i32 0, i32 1
Base Pointer Type: %struct.st*
Base Pointer   %strt = alloca %struct.st, align 4
Origin Base Pointer:   %strt = alloca %struct.st, align 4

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx12 = getelementptr inbounds [200 x [300 x float]]* %float_arr, i32 0, i64 %idxprom11
Base Pointer Type: [200 x [300 x float]]*
Base Pointer   %float_arr = getelementptr inbounds %struct.st* %strt, i32 0, i32 1
Origin Base Pointer:   %strt = alloca %struct.st, align 4

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0

Index (Non-constant):   %idxprom11 = zext i32 %9 to i64
NumElements: 200
Origin Index:   %9 = load i32* %i, align 4
var1:   %i = alloca i32, align 4
var2: i64 200
----------------------------------------------------------------------
----------------------------------------------------------------------
[GEP instruction detected]:   %arrayidx13 = getelementptr inbounds [300 x float]* %arrayidx12, i32 0, i64 %idxprom10
Base Pointer Type: [300 x float]*
Base Pointer   %arrayidx12 = getelementptr inbounds [200 x [300 x float]]* %float_arr, i32 0, i64 %idxprom11
Origin Base Pointer:   %strt = alloca %struct.st, align 4

First Index (Constant): 0
First index 0 passed compile-time check: 0 <= 0

Index (Non-constant):   %idxprom10 = zext i32 %add9 to i64
NumElements: 300
Origin Index:   %add9 = add i32 %8, 1
var1:   %add9 = add i32 %8, 1
var2: i64 300
----------------------------------------------------------------------
-------------------------------------------------------
Number of checks inserted: 14
-------------------------------------------------------

#########################################
Generating Effects
#########################################
Entering basic block
inst:   %retval = alloca i32, align 4
inst:   %a = alloca [300 x i32], align 16
inst:   %n = alloca i32, align 4
inst:   %saved_stack = alloca i8*
inst:   %i = alloca i32, align 4
inst:   %strt = alloca %struct.st, align 4
inst:   %cleanup.dest.slot = alloca i32
inst:   store i32 0, i32* %retval
inst:   store i32 50, i32* %n, align 4
inst:   %0 = load i32* %n, align 4
inst:   %1 = zext i32 %0 to i64
operand:   %0 = load i32* %n, align 4, !EFFECT !{metadata !"UNCHANGED", i32* %n, i64 0}
inst:   %2 = call i8* @llvm.stacksave()
inst:   store i8* %2, i8** %saved_stack
inst:   %vla = alloca i32, i64 %1, align 16
inst:   store i32 200, i32* %n, align 4
inst:   store i32 10, i32* %i, align 4
inst:   %3 = load i32* %i, align 4
inst:   %idxprom = zext i32 %3 to i64
operand:   %3 = load i32* %i, align 4, !EFFECT !{metadata !"UNCHANGED", i32* %i, i64 0}
inst:   call void @checkLTLimit(i64 %idxprom, i64 300), !VarName !{i32* %i, i64 300}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom), !VarName !{i64 0, i32* %i}
inst:   %arrayidx = getelementptr inbounds [300 x i32]* %a, i32 0, i64 %idxprom
inst:   store i32 100, i32* %arrayidx, align 4
inst:   %4 = load i32* %i, align 4
inst:   %add = add i32 %4, 1
  %add = add i32 %4, 1 BINOP: ADD
inst:   %idxprom1 = zext i32 %add to i64
operand:   %add = add i32 %4, 1, !EFFECT !{metadata !"INCREMENT", i32* %i, i64 1}
inst:   call void @checkLTLimit(i64 %idxprom1, i64 %1), !VarName !{i32 %add, i32* %n}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom1), !VarName !{i64 0, i32 %add}
inst:   %arrayidx2 = getelementptr inbounds i32* %vla, i64 %idxprom1
inst:   store i32 100, i32* %arrayidx2, align 4
inst:   %5 = load i32* %i, align 4
inst:   %idxprom3 = zext i32 %5 to i64
operand:   %5 = load i32* %i, align 4, !EFFECT !{metadata !"UNCHANGED", i32* %i, i64 0}
inst:   call void @checkLTLimit(i64 %idxprom3, i64 %1), !VarName !{i32* %i, i32* %n}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom3), !VarName !{i64 0, i32* %i}
inst:   %arrayidx4 = getelementptr inbounds i32* %vla, i64 %idxprom3
inst:   store i32 0, i32* %arrayidx4, align 4
inst:   %6 = load i32* %i, align 4
inst:   %idxprom5 = zext i32 %6 to i64
operand:   %6 = load i32* %i, align 4, !EFFECT !{metadata !"UNCHANGED", i32* %i, i64 0}
inst:   call void @checkLTLimit(i64 %idxprom5, i64 300), !VarName !{i32* %i, i64 300}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom5), !VarName !{i64 0, i32* %i}
inst:   %arrayidx6 = getelementptr inbounds [300 x i32]* %a, i32 0, i64 %idxprom5
inst:   store i32 0, i32* %arrayidx6, align 4
inst:   %7 = load i32* %i, align 4
inst:   %idxprom7 = zext i32 %7 to i64
operand:   %7 = load i32* %i, align 4, !EFFECT !{metadata !"UNCHANGED", i32* %i, i64 0}
inst:   %arr = getelementptr inbounds %struct.st* %strt, i32 0, i32 0
inst:   call void @checkLTLimit(i64 %idxprom7, i64 100), !VarName !{i32* %i, i64 100}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom7), !VarName !{i64 0, i32* %i}
inst:   %arrayidx8 = getelementptr inbounds [100 x i8]* %arr, i32 0, i64 %idxprom7
inst:   store i8 0, i8* %arrayidx8, align 1
inst:   %8 = load i32* %i, align 4
inst:   %add9 = add i32 %8, 1
  %add9 = add i32 %8, 1 BINOP: ADD
inst:   %idxprom10 = zext i32 %add9 to i64
operand:   %add9 = add i32 %8, 1, !EFFECT !{metadata !"INCREMENT", i32* %i, i64 1}
inst:   %9 = load i32* %i, align 4
inst:   %idxprom11 = zext i32 %9 to i64
operand:   %9 = load i32* %i, align 4, !EFFECT !{metadata !"UNCHANGED", i32* %i, i64 0}
inst:   %float_arr = getelementptr inbounds %struct.st* %strt, i32 0, i32 1
inst:   call void @checkLTLimit(i64 %idxprom11, i64 200), !VarName !{i32* %i, i64 200}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom11), !VarName !{i64 0, i32* %i}
inst:   %arrayidx12 = getelementptr inbounds [200 x [300 x float]]* %float_arr, i32 0, i64 %idxprom11
inst:   call void @checkLTLimit(i64 %idxprom10, i64 300), !VarName !{i32 %add9, i64 300}
inst:   call void @checkGTLimit(i64 0, i64 %idxprom10), !VarName !{i64 0, i32 %add9}
inst:   %arrayidx13 = getelementptr inbounds [300 x float]* %arrayidx12, i32 0, i64 %idxprom10
inst:   store float 0.000000e+00, float* %arrayidx13, align 4
inst:   store i32 0, i32* %retval
inst:   store i32 1, i32* %cleanup.dest.slot
inst:   %10 = load i8** %saved_stack
inst:   call void @llvm.stackrestore(i8* %10)
inst:   %11 = load i32* %retval
inst:   ret i32 %11
Exiting basic block


#########################################
DONE
#########################################

#########################################
VERY BUSY ANALYSIS
#########################################
union created: { (i < 300)  }
union: i < 300 AND 0 <= i
union created: { (i < 300) (0 <= i)  }
union: i < 300 AND add < n
union: 0 <= i AND add < n
union created: { (i < 300) (0 <= i) (add < n)  }
union: i < 300 AND -1 <= i
union: 0 <= i AND -1 <= i
		0 <= i SUBSUMES -1 <= i
union created: { (i < 300) (0 <= i) (add < n)  }
union: i < 300 AND i < n
union: 0 <= i AND i < n
union: add < n AND i < n
union created: { (i < 300) (0 <= i) (add < n) (i < n)  }
union: i < 300 AND 0 <= i
union: 0 <= i AND 0 <= i
union: add < n AND 0 <= i
union: i < n AND 0 <= i
union created: { (i < 300) (0 <= i) (add < n) (i < n)  }
union: i < 300 AND i < 300
union: 0 <= i AND i < 300
union: add < n AND i < 300
union: i < n AND i < 300
union created: { (i < 300) (0 <= i) (add < n) (i < n)  }
union: i < 300 AND 0 <= i
union: 0 <= i AND 0 <= i
union: add < n AND 0 <= i
union: i < n AND 0 <= i
union created: { (i < 300) (0 <= i) (add < n) (i < n)  }
union: i < 300 AND i < 100
		i < 100 SUBSUMES i < 300
union created: { (i < 100) (0 <= i) (add < n) (i < n)  }
union: i < 100 AND 0 <= i
union: 0 <= i AND 0 <= i
union: add < n AND 0 <= i
union: i < n AND 0 <= i
union created: { (i < 100) (0 <= i) (add < n) (i < n)  }
union: i < 100 AND i < 200
		i < 100 SUBSUMES i < 200
union created: { (i < 100) (0 <= i) (add < n) (i < n)  }
union: i < 100 AND 0 <= i
union: 0 <= i AND 0 <= i
union: add < n AND 0 <= i
union: i < n AND 0 <= i
union created: { (i < 100) (0 <= i) (add < n) (i < n)  }
union: i < 100 AND i < 299
		i < 100 SUBSUMES i < 299
union created: { (i < 100) (0 <= i) (add < n) (i < n)  }
union: i < 100 AND -1 <= i
union: 0 <= i AND -1 <= i
		0 <= i SUBSUMES -1 <= i
union created: { (i < 100) (0 <= i) (add < n) (i < n)  }
Universe: { (i < 100) (0 <= i) (add < n) (i < n)  }
******************* ROUND 0*************************
Basic Block: entry
OUT = {  }
		Not a Check Call:   call void @llvm.stackrestore(i8* %10)
		RCS Generated: -1 <= i
		IN: { (-1 <= i)  }
		RCS Generated: i < 299
union: -1 <= i AND i < 299
		IN: { (-1 <= i) (i < 299)  }
		RCS Generated: 0 <= i
union: -1 <= i AND 0 <= i
		0 <= i SUBSUMES -1 <= i
		IN: { (0 <= i) (i < 299)  }
		RCS Generated: i < 200
union: 0 <= i AND i < 200
union: i < 299 AND i < 200
		i < 200 SUBSUMES i < 299
		IN: { (0 <= i) (i < 200)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 200 AND 0 <= i
		IN: { (0 <= i) (i < 200)  }
		RCS Generated: i < 100
union: 0 <= i AND i < 100
union: i < 200 AND i < 100
		i < 100 SUBSUMES i < 200
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 100 AND 0 <= i
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: i < 300
union: 0 <= i AND i < 300
union: i < 100 AND i < 300
		i < 100 SUBSUMES i < 300
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 100 AND 0 <= i
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: i < n
union: 0 <= i AND i < n
union: i < 100 AND i < n
		IN: { (0 <= i) (i < 100) (i < n)  }
		RCS Generated: -1 <= i
union: 0 <= i AND -1 <= i
		0 <= i SUBSUMES -1 <= i
		IN: { (0 <= i) (i < 100) (i < n)  }
		RCS Generated: add < n
union: 0 <= i AND add < n
union: i < 100 AND add < n
union: i < n AND add < n
		IN: { (0 <= i) (i < 100) (i < n) (add < n)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 100 AND 0 <= i
union: i < n AND 0 <= i
union: add < n AND 0 <= i
		IN: { (0 <= i) (i < 100) (i < n) (add < n)  }
		RCS Generated: i < 300
union: 0 <= i AND i < 300
union: i < 100 AND i < 300
		i < 100 SUBSUMES i < 300
		IN: { (0 <= i) (i < 100) (i < n) (add < n)  }
		0 <= i got KILLED
		i < 100 got KILLED
		i < n got KILLED
		Not a Check Call:   %2 = call i8* @llvm.stacksave()
IN = { (add < n)  }
IN_PREV = { (i < 100) (0 <= i) (add < n) (i < n)  }
changed

***************************************************
******************* ROUND 1*************************
Basic Block: entry
OUT = {  }
		Not a Check Call:   call void @llvm.stackrestore(i8* %10)
		RCS Generated: -1 <= i
		IN: { (-1 <= i)  }
		RCS Generated: i < 299
union: -1 <= i AND i < 299
		IN: { (-1 <= i) (i < 299)  }
		RCS Generated: 0 <= i
union: -1 <= i AND 0 <= i
		0 <= i SUBSUMES -1 <= i
		IN: { (0 <= i) (i < 299)  }
		RCS Generated: i < 200
union: 0 <= i AND i < 200
union: i < 299 AND i < 200
		i < 200 SUBSUMES i < 299
		IN: { (0 <= i) (i < 200)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 200 AND 0 <= i
		IN: { (0 <= i) (i < 200)  }
		RCS Generated: i < 100
union: 0 <= i AND i < 100
union: i < 200 AND i < 100
		i < 100 SUBSUMES i < 200
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 100 AND 0 <= i
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: i < 300
union: 0 <= i AND i < 300
union: i < 100 AND i < 300
		i < 100 SUBSUMES i < 300
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 100 AND 0 <= i
		IN: { (0 <= i) (i < 100)  }
		RCS Generated: i < n
union: 0 <= i AND i < n
union: i < 100 AND i < n
		IN: { (0 <= i) (i < 100) (i < n)  }
		RCS Generated: -1 <= i
union: 0 <= i AND -1 <= i
		0 <= i SUBSUMES -1 <= i
		IN: { (0 <= i) (i < 100) (i < n)  }
		RCS Generated: add < n
union: 0 <= i AND add < n
union: i < 100 AND add < n
union: i < n AND add < n
		IN: { (0 <= i) (i < 100) (i < n) (add < n)  }
		RCS Generated: 0 <= i
union: 0 <= i AND 0 <= i
union: i < 100 AND 0 <= i
union: i < n AND 0 <= i
union: add < n AND 0 <= i
		IN: { (0 <= i) (i < 100) (i < n) (add < n)  }
		RCS Generated: i < 300
union: 0 <= i AND i < 300
union: i < 100 AND i < 300
		i < 100 SUBSUMES i < 300
		IN: { (0 <= i) (i < 100) (i < n) (add < n)  }
		0 <= i got KILLED
		i < 100 got KILLED
		i < n got KILLED
		Not a Check Call:   %2 = call i8* @llvm.stacksave()
IN = { (add < n)  }
IN_PREV = { (add < n)  }
unchanged

***************************************************

#########################################
MODIFYCHECK PASS
#########################################
Very Busy Expressions: { (0 <= i) (i < 100) (i < n) (add < n)  }
Replacing i < 300 with i < 100
Very Busy Expressions: { (0 <= i) (i < 100) (i < n) (add < n)  }
Very Busy Expressions: { (0 <= i) (i < 100) (i < n)  }
Very Busy Expressions: { (0 <= i) (i < 100) (i < n)  }
Replacing -1 <= i with 0 <= i
Very Busy Expressions: { (0 <= i) (i < 100)  }
Very Busy Expressions: { (0 <= i) (i < 100)  }
Very Busy Expressions: { (0 <= i) (i < 100)  }
Very Busy Expressions: { (0 <= i) (i < 100)  }
Very Busy Expressions: { (0 <= i) (i < 200)  }
Very Busy Expressions: { (0 <= i) (i < 200)  }
Very Busy Expressions: { (0 <= i) (i < 299)  }
Very Busy Expressions: { (-1 <= i) (i < 299)  }
Very Busy Expressions: { (-1 <= i)  }
Very Busy Expressions: {  }

#########################################
DONE
#########################################
Call parameter type does not match function signature!
  %i = alloca i32, align 4
 i64  call void @checkGTLimit(i32* %i, i64 %idxprom1), !VarName !{i32* %i, i32 %add}
Broken module found, compilation aborted!
0  opt             0x00000000011a83ff
1  opt             0x00000000011a8929
2  libpthread.so.0 0x00007f4db2456060
3  libc.so.6       0x00007f4db17343e5 gsignal + 53
4  libc.so.6       0x00007f4db1737b4b abort + 379
5  opt             0x0000000001158e48
6  opt             0x000000000116499d
7  opt             0x000000000113c9ef llvm::FPPassManager::runOnFunction(llvm::Function&) + 591
8  opt             0x000000000113ca63 llvm::FPPassManager::runOnModule(llvm::Module&) + 51
9  opt             0x000000000113c704 llvm::MPPassManager::runOnModule(llvm::Module&) + 532
10 opt             0x000000000113fa5b llvm::PassManagerImpl::run(llvm::Module&) + 171
11 opt             0x0000000000552af7 main + 5815
12 libc.so.6       0x00007f4db171f30d __libc_start_main + 237
13 opt             0x00000000005681b9
Stack dump:
0.	Program arguments: ./../../Release+Asserts/bin/opt -load ../../Release+Asserts/lib/llvm-array-check-pass.so -modify-check -debug-pass=Structure -S -o ./tests/local.mod.ll 
1.	Running pass 'Function Pass Manager' on module '<stdin>'.
2.	Running pass 'Module Verifier' on function '@main'
./runPass.sh: line 54: 21646 Aborted                 ./$OPT -load $MODULE_LIB $OPT_PASSES -debug-pass=Structure -S -o $TEST_NAME.mod.ll < $TEST_NAME.ll > /dev/null
clang: error: no such file or directory: './tests/local.mod.ll'
